@page "/rooms/colliders"
@model Web.Razor.Pages.Rooms.CollidersModel
@{
    ViewData["Title"] = "Room Colliders";
}
@section Stylesheets {
    <style>
        :root {
            --c-bg-panel: linear-gradient(145deg,#0f1f29,#142e3b 55%,#0d1a22);
            --c-border-panel: #1f4457;
            --c-border-subtle: #203c4a;
            --c-border-strong: #1d566f;
            --c-accent: #2fa8d8;
            --c-text: #e1f6ff;
            --c-text-dim: #b7d3df;
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --radius-sm: 4px;
            --radius-md: 8px;
            --shadow-panel: 0 2px 6px rgba(0,0,0,0.4), inset 0 0 10px rgba(0,0,0,0.35);
        }

    #colliderCanvas { width:100%; height:70vh; border:1px solid #1d4150; background:radial-gradient(circle at 35% 40%, #0e2735 0%, #081923 60%, #06151d 100%); cursor:grab; border-radius:18px; box-shadow:0 0 0 1px #0d2631, 0 6px 26px -6px rgba(0,0,0,0.55), inset 0 0 42px -8px rgba(0,160,210,0.25); position:relative; }
        .canvas-wrapper { position:relative; }
        .status-group { display:flex; flex-wrap:wrap; gap:var(--space-2); margin-top:var(--space-2); }
        #status, #stats, #hoverInfo, #colliderDetail { background:rgba(25,40,50,0.55); backdrop-filter:blur(2px); border:1px solid rgba(90,170,200,0.35); border-radius:var(--radius-sm); padding:2px 6px; color:#e8f7ff !important; font-weight:500; text-shadow:0 0 3px rgba(0,0,0,0.7); }
        .auto-hide:empty { display:none !important; }
        #hoverInfo { margin-top:4px; }
        #roomList { max-height:28vh; overflow:auto; border:1px solid var(--c-border-subtle); border-radius:var(--radius-sm); scroll-behavior:smooth; }
        .collider-item { font-size:12px; line-height:1.15; padding:4px 8px; }
        #roomList .list-group-item.collider-item { background:#133043; color:#f0f6fc; border:0; border-bottom:1px solid #0f2735; }
        #roomList .list-group-item.collider-item:last-child { border-bottom:0; }
        #roomList .list-group-item.collider-item:hover { background:#19465f; color:#ffffff; }
        #roomList .list-group-item.collider-item.active-room { background:#256d8f; color:#fff; font-weight:600; }

    .collider-side { position:sticky; top:var(--space-3); background:linear-gradient(160deg,#112836,#0f2430 45%,#0a1b23); border:1px solid #1d4254; border-radius:18px; padding:20px 18px 22px; box-shadow:0 4px 18px -4px rgba(0,0,0,0.6), inset 0 0 0 1px rgba(255,255,255,0.03); display:flex; flex-direction:column; gap:18px; font-size:13px; backdrop-filter:blur(4px) saturate(130%); }
    .collider-side h5.page-title { margin:0 0 var(--space-1); color:#f5fbff; font-weight:600; letter-spacing:.5px; text-shadow:0 1px 2px #000; font-size:1.1rem; display:flex; align-items:center; gap:6px; }
    .panel-section { display:flex; flex-direction:column; gap:var(--space-2); }
    .panel-section + .panel-section { border-top:1px solid rgba(255,255,255,0.05); padding-top:var(--space-3); }
    .panel-section h5 { margin:0; color:#f5fbff; font-weight:600; font-size:.9rem; letter-spacing:.5px; display:flex; align-items:center; gap:6px; }
    .panel-section h6 { margin:0; color:#d6ecf5; font-weight:600; font-size:.7rem; letter-spacing:.75px; text-transform:uppercase; opacity:.85; }
    .panel-section.primary h5 { position:relative; padding-left:10px; }
    .panel-section.primary h5:before { content:""; position:absolute; left:0; top:50%; transform:translateY(-50%); width:4px; height:60%; background:var(--c-accent); border-radius:2px; box-shadow:0 0 6px rgba(47,168,216,.6); }
        .panel-small { font-size:11px; color:var(--c-text-dim); }
        .legend { display:grid; grid-template-columns:repeat(auto-fill,minmax(70px,1fr)); gap:4px; }
        .legend span { display:inline-flex; align-items:center; justify-content:center; padding:2px 4px; border-radius:var(--radius-sm); font-size:10px; line-height:1.1; border:1px solid rgba(255,255,255,0.12); background:#1a2f3b; color:#dff7ff; font-weight:500; }
        .filter-swatch { display:inline-block; width:14px; height:14px; border:1px solid rgba(0,0,0,0.55); margin-right:4px; border-radius:3px; box-shadow:0 0 0 1px rgba(0,0,0,0.6), 0 0 4px rgba(0,0,0,0.5); }
        #filterList { display:grid; grid-template-columns:repeat(auto-fill,minmax(120px,1fr)); gap:2px 6px; }
        #filterList .form-check { padding:2px 2px; margin:0; display:flex; align-items:center; gap:6px; background:#123040; border:1px solid #1d4558; border-radius:var(--radius-sm); }
        #filterList .form-check:hover { background:#16495e; }
        #filterList .form-check-input { margin:0; position:static; width:16px; height:16px; cursor:pointer; background:#1b3643; border:1px solid #2a5f77; }
        #filterList .form-check-input:checked { background:var(--c-accent); border-color:var(--c-accent); }
        #filterList label { cursor:pointer; user-select:none; display:flex; align-items:center; gap:6px; margin:0; font-size:11px; color:var(--c-text); }
    .btn-outline-dark, .btn-light { background:linear-gradient(145deg,#15394a,#132f3d); color:#e0f8ff; border:1px solid #1e5166; border-radius:10px; font-weight:500; letter-spacing:.3px; position:relative; overflow:hidden; }
    .btn-outline-dark::after, .btn-light::after { content:""; position:absolute; inset:0; background:linear-gradient(120deg,rgba(255,255,255,0.08),rgba(255,255,255,0)); opacity:0; transition:opacity .25s; }
    .btn-outline-dark:hover::after, .btn-light:hover::after { opacity:1; }
    .btn-outline-dark:hover, .btn-light:hover, .btn-outline-dark.active { background:linear-gradient(145deg,#1d566f,#194c63); color:#fff; box-shadow:0 0 0 1px #226d8a, 0 0 8px -1px rgba(47,168,216,0.5); }
        .form-check-input { background:#1b3643; border:1px solid #2a5f77; }
        .form-check-input:checked { background:var(--c-accent); border-color:var(--c-accent); }
    .input-group-sm > .form-control { background:#123040; border:1px solid var(--c-border-strong); color:var(--c-text); }
    .input-group-sm > .form-control:focus { background:#163b4d; color:#fff; }
    .input-group-sm .btn { background:#123040; border:1px solid var(--c-border-strong); color:var(--c-text); }
    .input-group-sm .btn:hover { background:#1d566f; color:#fff; }
    .input-group-sm .form-control, .input-group-sm .btn { height:30px; }
    .section-inline-controls { display:flex; flex-wrap:wrap; gap:6px; }
    #displayToggles button.toggle-btn { min-width:56px; font-size:11px; padding:4px 10px; line-height:1.1; border-radius:12px; transition:background .25s, box-shadow .25s, transform .25s; }
    #displayToggles button.toggle-btn.active { background:linear-gradient(145deg,#2186ab,#1c6f8d); box-shadow:0 0 0 1px #2fa8d8, 0 0 10px -2px rgba(47,168,216,0.7); }
    #displayToggles button.toggle-btn:not(.active):hover { background:#19465f; }
    #displayHint { color:#7fbfd6; font-size:10px; margin-top:4px; text-shadow:0 0 4px rgba(0,0,0,0.4); }

    /* Search group restyle */
    .search-group { display:flex; align-items:stretch; width:100%; background:linear-gradient(135deg,#133544,#0f2935); border:1px solid #1e5166; border-radius:14px; overflow:hidden; box-shadow:0 4px 14px -6px rgba(0,0,0,0.6), inset 0 0 0 1px rgba(255,255,255,0.03); }
    .search-group input { background:transparent; border:0; color:#dff7ff; padding:8px 14px; font-size:12px; flex:1; outline:none; }
    .search-group input::placeholder { color:#5d8897; }
    .search-group button { background:linear-gradient(145deg,#1d566f,#1a4e63); border:0; color:#e6fbff; padding:0 20px; display:flex; align-items:center; justify-content:center; font-size:11px; font-weight:600; cursor:pointer; letter-spacing:.5px; }
    .search-group button:hover { background:linear-gradient(145deg,#227797,#1d6078); }
    .search-group button:active { transform:translateY(1px); }

    /* Room list polish */
    #roomList .collider-item { border-radius:10px; margin:2px 4px; background:linear-gradient(145deg,#132f3f,#102633); border:1px solid #1a4558; transition:background .25s, transform .25s, box-shadow .25s; }
    #roomList .collider-item:hover { background:#19465f; transform:translateY(-1px); }
    #roomList .collider-item.active-room { background:linear-gradient(145deg,#256d8f,#1d5a77); box-shadow:0 0 0 1px #2fa8d8, 0 0 10px -2px rgba(47,168,216,.6); }

    #roomList::-webkit-scrollbar { width:10px; }
    #roomList::-webkit-scrollbar-track { background:#0f2531; border-radius:8px; }
    #roomList::-webkit-scrollbar-thumb { background:linear-gradient(#1f566c,#1b4d61); border-radius:8px; border:2px solid #0f2531; }
    #roomList::-webkit-scrollbar-thumb:hover { background:linear-gradient(#276f8a,#236175); }

    .status-group > div { border-radius:14px !important; padding:4px 10px !important; background:linear-gradient(135deg,rgba(32,74,92,0.65),rgba(18,50,64,0.65)); backdrop-filter:blur(4px); box-shadow:0 0 0 1px rgba(47,168,216,0.25), 0 4px 14px -6px rgba(0,0,0,.65); }
    #hoverInfo { font-weight:500; }
    .canvas-wrapper:focus-within #colliderCanvas { outline:2px solid var(--c-accent); outline-offset:4px; }
        ul.compact-list { list-style:disc; padding-left:16px; margin:0; display:flex; flex-direction:column; gap:2px; }
        ul.compact-list li { color:#d6ecf5; font-size:11px; }
        .export-group .btn { flex:1; }
        .collider-side #colliderDetail { min-height:18px; }
        .canvas-wrapper:focus-within #colliderCanvas { outline:2px solid var(--c-accent); }
    </style>
}
<div class="container-fluid mt-3">
    <div class="row">
        <div class="col-md-3">
            <div class="collider-side" role="complementary" aria-label="Colliders sidebar">
                <h5 class="page-title">@ViewData["ServerName"] Rooms</h5>

                <div class="panel-section primary" aria-labelledby="rooms-heading">
                    <h5 id="rooms-heading">Rooms</h5>
                    <div id="roomList" class="list-group"></div>
                </div>

                <div class="panel-section primary" aria-labelledby="filters-heading">
                    <h5 id="filters-heading">Filters</h5>
                    <div id="filterList"></div>
                </div>

                <div class="panel-section primary" aria-labelledby="display-heading">
                    <h5 id="display-heading">Display</h5>
                    <div class="section-inline-controls" id="displayToggles" style="gap:6px; flex-wrap:wrap;">
                        <button id="btnFit" class="btn btn-sm btn-light" title="Fit current room bounds (F)">Fit</button>
                        <button data-key="autoFit" class="btn btn-sm btn-outline-dark toggle-btn active" title="Auto-fit when bounds expand">Auto</button>
                        <button data-key="bbox" class="btn btn-sm btn-outline-dark toggle-btn" title="Show room bounding box">BBox</button>
                        <button data-key="grid" class="btn btn-sm btn-outline-dark toggle-btn active" title="Show grid">Grid</button>
                        <button data-key="flash" class="btn btn-sm btn-outline-dark toggle-btn active" title="Flash changed colliders">Flash</button>
                        <button data-key="inactive" class="btn btn-sm btn-outline-dark toggle-btn active" title="Show inactive colliders">Inactive</button>
                        <button data-key="invisible" class="btn btn-sm btn-outline-dark toggle-btn active" title="Show invisible colliders (faded)">Invisible</button>
                    </div>
                    <div class="panel-small" id="displayHint">Flash highlights new/updated shapes for 1.5s.</div>
                </div>

                <div class="panel-section" aria-labelledby="search-heading">
                    <h5 id="search-heading">Search</h5>
                    <div class="search-group" role="search">
                        <input type="text" id="searchCollider" placeholder="Collider id..." aria-label="Collider search" />
                        <button id="searchBtn" title="Find collider by ID">FIND</button>
                    </div>
                </div>

                <div class="panel-section export-group" aria-labelledby="export-heading">
                    <h5 id="export-heading">Export</h5>
                    <div class="btn-group btn-group-sm w-100" role="group">
                        <button id="exportJson" class="btn btn-outline-dark" title="Download collider list as JSON">JSON</button>
                        <button id="exportPng" class="btn btn-outline-dark" title="Download canvas as PNG">PNG</button>
                    </div>
                </div>

                <div class="panel-section" aria-labelledby="controls-heading">
                    <h5 id="controls-heading">Controls</h5>
                    <ul class="compact-list">
                        <li>Drag to pan</li>
                        <li>Scroll to zoom</li>
                        <li>Double-click to reset view</li>
                    </ul>
                    <div id="colliderDetail" class="small auto-hide mt-1" aria-label="Collider details"></div>
                </div>
            </div>
        </div>
        <div class="col-md-9">
            <div class="canvas-wrapper">
                <canvas id="colliderCanvas" aria-label="Collider visualization" tabindex="0"></canvas>
            </div>
            <div class="status-group">
                <div id="status" class="small"></div>
                <div id="stats" class="small auto-hide"></div>
                <div id="hoverInfo" class="small auto-hide"></div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        const hub = new signalR.HubConnectionBuilder().withUrl('/hubs/colliders').withAutomaticReconnect().build();
        let rooms = []; let currentRoom = null; let colliders = []; let scale = 32; // world units to pixels
        let zoom = 1; let offsetX = 0; let offsetY = 0; let isPanning = false; let startPan = { x: 0, y: 0 };
        const colors = { Attack: '#ff6b6b', Player: '#4ecdc4', Enemy: '#ffe66d', Default: '#1a535c', Breakable: '#a29bfe', Hazard: '#ff922b', MovingPlatform: '#74c0fc', TriggerTarget: '#e599f7', TriggerReceiver: '#be4bdb', Stomper: '#ff8787', AiAttack: '#ff6b6b' };
        let activeTypes = new Set(Object.keys(colors));
        let version = 0;
        const changeFlash = new Map();
        const FLASH_MS = 1500;
        let lastBbox = null;
        let pendingStats = null;
        // Unified display state
        const displayState = {
            autoFit: true,
            bbox: false,
            grid: true,
            flash: true,
            inactive: true,
            invisible: true
        };
        let selectedColliderId = null;
        let fpsFrameCount = 0; let fpsLastTime = performance.now(); let fps = 0;
        let pageActive = true; // false when tab hidden
        let intentionalStop = false; // prevent auto-reconnect when intentionally suspended

        // Normalization helper to guard against casing differences from server
        function normalizeCollider(c) {
            if (!c) return c;
            return {
                ...c,
                id: c.id ?? c.Id ?? '',
                type: c.type ?? c.Type ?? 'Default',
                active: (c.active ?? c.Active ?? true),
                invisible: (c.invisible ?? c.Invisible ?? false),
                plane: c.plane ?? c.Plane ?? 0,
                x: c.x,
                y: c.y,
                width: c.width,
                height: c.height
            };
        }

        function fitView() {
            if (colliders.length === 0) return;
            const minX = Math.min(...colliders.map(c => c.x));
            const minY = Math.min(...colliders.map(c => c.y));
            const maxX = Math.max(...colliders.map(c => c.x + c.width));
            const maxY = Math.max(...colliders.map(c => c.y + c.height));
            const canvas = document.getElementById('colliderCanvas');
            const padding = 2;
            const w = maxX - minX + padding * 2; const h = maxY - minY + padding * 2;
            zoom = Math.min(canvas.width / (w * scale), canvas.height / (h * scale));
            offsetX = -(minX - padding) * scale * zoom + (canvas.width - w * scale * zoom) / 2;
            offsetY = -(minY - padding) * scale * zoom + (canvas.height - h * scale * zoom) / 2;
        }

        function draw() {
            if (!pageActive) return;
            const canvas = document.getElementById('colliderCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);
            if (displayState.grid) {
                ctx.save();
                const gridSize = scale; // 1 world unit squares
                const visibleWorldW = canvas.width / (zoom * scale);
                const visibleWorldH = canvas.height / (zoom * scale);
                const centerWorldX = ((canvas.width / 2) - offsetX) / (zoom * scale);
                const centerWorldY = -(((canvas.height / 2) - offsetY) / (zoom * scale));
                const minX = Math.floor(centerWorldX - visibleWorldW / 2) - 2;
                const maxX = Math.ceil(centerWorldX + visibleWorldW / 2) + 2;
                const minY = Math.floor(centerWorldY - visibleWorldH / 2) - 2;
                const maxY = Math.ceil(centerWorldY + visibleWorldH / 2) + 2;
                ctx.lineWidth = 1 / zoom;
                for (let x = minX; x <= maxX; x++) {
                    ctx.beginPath();
                    ctx.strokeStyle = (x % 5 === 0) ? 'rgba(90,170,200,0.25)' : 'rgba(40,90,115,0.35)';
                    ctx.moveTo(x * gridSize, -(minY) * gridSize);
                    ctx.lineTo(x * gridSize, -(maxY) * gridSize);
                    ctx.stroke();
                }
                for (let y = minY; y <= maxY; y++) {
                    ctx.beginPath();
                    ctx.strokeStyle = (y % 5 === 0) ? 'rgba(90,170,200,0.25)' : 'rgba(40,90,115,0.35)';
                    ctx.moveTo(minX * gridSize, -y * gridSize);
                    ctx.lineTo(maxX * gridSize, -y * gridSize);
                    ctx.stroke();
                }
                // axis highlight
                ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth = 1.5 / zoom;
                ctx.beginPath(); ctx.moveTo(0, -(minY) * gridSize); ctx.lineTo(0, -(maxY) * gridSize); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(minX * gridSize, 0); ctx.lineTo(maxX * gridSize, 0); ctx.stroke();
                ctx.restore();
            }
            const now = performance.now();
            const showInactive = displayState.inactive;
            const showInvisible = displayState.invisible;
            for (const c of colliders) {
                if (!activeTypes.has(c.type)) continue;
                if (!showInactive && !c.active) continue;
                if (!showInvisible && c.invisible) continue;
                const color = colors[c.type] || colors.Default;
                let baseColor = c.active ? color : '#555';
                const t = changeFlash.get(c.id);
                if (displayState.flash && t && now - t < FLASH_MS) {
                    const alpha = 1 - (now - t) / FLASH_MS;
                    ctx.fillStyle = shadeColor(baseColor, alpha * 40);
                } else {
                    ctx.fillStyle = baseColor;
                }
                ctx.globalAlpha = c.invisible ? 0.3 : 0.8;
                ctx.fillRect(c.x * scale, (-(c.y + c.height)) * scale, c.width * scale, c.height * scale);
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1 / zoom;
                ctx.strokeRect(c.x * scale, (-(c.y + c.height)) * scale, c.width * scale, c.height * scale);
                if (selectedColliderId === c.id) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2 / zoom;
                    ctx.strokeRect(c.x * scale, (-(c.y + c.height)) * scale, c.width * scale, c.height * scale);
                }
            }
            if (displayState.bbox && lastBbox) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.setLineDash([6 / zoom, 4 / zoom]);
                ctx.lineWidth = 1.5 / zoom;
                ctx.strokeRect(lastBbox.minX * scale, (-(lastBbox.minY + lastBbox.height)) * scale, lastBbox.width * scale, lastBbox.height * scale);
                ctx.restore();
            }
            ctx.restore();
            document.getElementById('status').innerText = currentRoom ? `${currentRoom.name} | V${version} | Colliders: ${colliders.length} | Zoom: ${zoom.toFixed(2)} | FPS: ${fps.toFixed(0)}` : 'No room selected';
            if (pendingStats) { const statsEl = document.getElementById('stats'); if (statsEl) statsEl.innerText = `Δ Added:${pendingStats.added} Updated:${pendingStats.updated} Removed:${pendingStats.removed} Bounds: ${pendingStats.bbox.width.toFixed(1)}x${pendingStats.bbox.height.toFixed(1)}`; pendingStats = null; }
            // Only continue animating if flash is enabled and there are flashing items, or a collider stays selected (for outline clarity)
            if (pageActive && ((displayState.flash && changeFlash.size > 0) || selectedColliderId)) scheduleNextFrame();
            fpsFrameCount++; const nowTs = performance.now(); if (nowTs - fpsLastTime >= 1000) { fps = (fpsFrameCount * 1000) / (nowTs - fpsLastTime); fpsFrameCount = 0; fpsLastTime = nowTs; }
        }
        const MAX_FPS = 30; let lastFrameTs = 0;
        function scheduleNextFrame() {
            if (!pageActive) return;
            requestAnimationFrame(ts => {
                if (!pageActive) return; // re-check after frame
                if (ts - lastFrameTs >= 1000 / MAX_FPS) {
                    lastFrameTs = ts;
                    draw();
                } else if (changeFlash.size > 0 || selectedColliderId) {
                    scheduleNextFrame();
                }
            });
        }

        function shadeColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            let r = (num >> 16) + percent;
            let g = ((num >> 8) & 0x00FF) + percent;
            let b = (num & 0x0000FF) + percent;
            r = Math.min(255, Math.max(0, r)); g = Math.min(255, Math.max(0, g)); b = Math.min(255, Math.max(0, b));
            return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
        }

        function resizeCanvas() { const canvas = document.getElementById('colliderCanvas'); canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; draw(); }
        window.addEventListener('resize', () => { resizeCanvas(); fitView(); draw(); });

        function buildFilters() {
            const container = document.getElementById('filterList');
            container.innerHTML = '';
            Object.keys(colors).forEach(t => {
                const id = 'flt_' + t;
                const swatch = colors[t] || '#1a535c';
                const div = document.createElement('div');
                div.className = 'form-check';
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'form-check-input';
                input.id = id;
                input.checked = activeTypes.has(t);
                const label = document.createElement('label');
                label.className = 'form-check-label small';
                label.setAttribute('for', id);
                const span = document.createElement('span');
                span.className = 'filter-swatch';
                span.style.background = swatch;
                label.appendChild(span);
                label.appendChild(document.createTextNode(t));
                div.appendChild(input);
                div.appendChild(label);
                container.appendChild(div);
                input.addEventListener('change', e => { if (e.target.checked) activeTypes.add(t); else activeTypes.delete(t); draw(); });
            });
        }
        async function loadRooms() {
            rooms = await hub.invoke('GetRooms'); const list = document.getElementById('roomList'); list.innerHTML = '';
            rooms.forEach(r => {
                 const a = document.createElement('a');
                 a.href = '#';
                 a.className = 'list-group-item list-group-item-action collider-item';
                 const levelId = r.levelId ?? r.LevelId ?? '?';
                 const roomInstanceId = r.roomInstanceId ?? r.RoomInstanceId ?? '?';
                 const name = r.name ?? r.Name ?? 'Unnamed';
                 a.textContent = `${levelId}:${roomInstanceId} ${name}`;
                 a.dataset.levelId = levelId;
                 a.dataset.roomInstanceId = roomInstanceId;
                 a.onclick = (e) => { e.preventDefault(); selectRoom(r); highlightActiveRoom(levelId, roomInstanceId); };
                 list.appendChild(a);
            });
            buildFilters();
             if (currentRoom) highlightActiveRoom(currentRoom.levelId, currentRoom.roomInstanceId);
         }

        async function selectRoom(r) {
            if (currentRoom) await hub.invoke('UnsubscribeRoom', currentRoom.levelId, currentRoom.roomInstanceId);
            currentRoom = { levelId: r.levelId ?? r.LevelId, roomInstanceId: r.roomInstanceId ?? r.RoomInstanceId, name: r.name ?? r.Name ?? 'Unnamed' };
            // Clear transient panels
            const detailEl = document.getElementById('colliderDetail'); if (detailEl) detailEl.textContent='';
            const statsEl = document.getElementById('stats'); if (statsEl) statsEl.textContent='';
            const hoverEl = document.getElementById('hoverInfo'); if (hoverEl) hoverEl.textContent='';
            const data = await hub.invoke('SubscribeRoom', currentRoom.levelId, currentRoom.roomInstanceId);
            if (data) {
                colliders = (data.colliders || data.Colliders || []).map(normalizeCollider);
                version = data.version || 0;
                lastBbox = data.bbox || null;
                changeFlash.clear();
                colliders.forEach(c => changeFlash.set(c.id, performance.now()));
                const restored = restoreView();
                if (!restored) {
                    fitView();
                }
                persistView();
                highlightActiveRoom(currentRoom.levelId, currentRoom.roomInstanceId);
                draw();
            }
        }
        function highlightActiveRoom(levelId, roomInstanceId) {
            const list = document.getElementById('roomList'); if (!list) return;
            [...list.querySelectorAll('.collider-item')].forEach(a => a.classList.toggle('active-room', a.dataset.levelId == levelId && a.dataset.roomInstanceId == roomInstanceId));
        }

    hub.on('collidersUpdated', payload => { if (!currentRoom) return; if (payload.levelId === currentRoom.levelId && payload.roomInstanceId === currentRoom.roomInstanceId) { colliders = (payload.colliders || []).map(normalizeCollider); version = payload.version || version + 1; lastBbox = payload.bbox || lastBbox; fitView(); persistView(); draw(); } });
    hub.on('collidersReset', payload => { if (!currentRoom) return; if (payload.levelId === currentRoom.levelId && payload.roomInstanceId === currentRoom.roomInstanceId) { colliders = (payload.colliders || []).map(normalizeCollider); version = payload.version || 0; lastBbox = payload.bbox || null; changeFlash.clear(); colliders.forEach(c => changeFlash.set(c.id, performance.now())); fitView(); persistView(); draw(); } });
        hub.on('collidersDiff', payload => {
            if (!currentRoom) return;
            if (payload.levelId !== currentRoom.levelId || payload.roomInstanceId !== currentRoom.roomInstanceId) return;
            if (payload.version && payload.version <= version) return; // stale
            version = payload.version || version + 1;
            if (payload.removed) { const remSet = new Set(payload.removed); colliders = colliders.filter(c => !remSet.has(c.id)); }
            if (payload.updated) { const map = new Map(colliders.map(c => [c.id, c])); payload.updated.forEach(u => { const id = u.id ?? u.Id; if (map.has(id)) { Object.assign(map.get(id), normalizeCollider(u)); changeFlash.set(id, performance.now()); } }); colliders = Array.from(map.values()); }
            if (payload.added) { payload.added.forEach(a => { const na = normalizeCollider(a); colliders.push(na); changeFlash.set(na.id, performance.now()); }); }
            if (payload.bbox) { if (lastBbox) { const growth = (payload.bbox.width * payload.bbox.height) / (lastBbox.width * lastBbox.height + 0.0001); if (growth > 1.25 && displayState.autoFit) fitView(); } lastBbox = payload.bbox; }
            if (payload.stats) { pendingStats = { ...payload.stats, bbox: payload.bbox || { width: 0, height: 0 } }; }
            persistView();
            draw();
        });

        // Dynamic room list updates
        hub.on('roomAdded', payload => {
            if (!payload) return;
            if (rooms.some(r => (r.levelId ?? r.LevelId) === payload.levelId && (r.roomInstanceId ?? r.RoomInstanceId) === payload.roomInstanceId)) return;
            rooms.push({ levelId: payload.levelId, roomInstanceId: payload.roomInstanceId, name: payload.name });
            appendRoomToList(payload.levelId, payload.roomInstanceId, payload.name);
        });

        hub.on('roomRemoved', payload => {
            if (!payload) return;
            rooms = rooms.filter(r => (r.levelId ?? r.LevelId) !== payload.levelId || (r.roomInstanceId ?? r.RoomInstanceId) !== payload.roomInstanceId);
            const list = document.getElementById('roomList');
            const item = list?.querySelector(`.collider-item[data-levelid="${payload.levelId}"][data-roominstanceid="${payload.roomInstanceId}"]`);
            if (item) item.remove();
            if (currentRoom && currentRoom.levelId === payload.levelId && currentRoom.roomInstanceId === payload.roomInstanceId) {
                currentRoom = null; colliders = []; version = 0; lastBbox = null; draw();
            }
        });

        function appendRoomToList(levelId, roomInstanceId, name) {
            const list = document.getElementById('roomList'); if (!list) return;
            const a = document.createElement('a');
            a.href = '#';
            a.className = 'list-group-item list-group-item-action collider-item';
            a.textContent = `${levelId}:${roomInstanceId} ${name || 'Unnamed'}`;
            a.dataset.levelId = levelId; a.dataset.roomInstanceId = roomInstanceId; // existing camelCase usage
            // duplicate attributes in lowercase for query selectors used on removal
            a.setAttribute('data-levelid', levelId);
            a.setAttribute('data-roominstanceid', roomInstanceId);
            a.onclick = (e) => { e.preventDefault(); const r = { levelId, roomInstanceId, name }; selectRoom(r); highlightActiveRoom(levelId, roomInstanceId); };
            list.appendChild(a);
        }

    function persistView() { if (!currentRoom) return; const state = { zoom, offsetX, offsetY, active: [...activeTypes], displayState }; localStorage.setItem('colliderView_' + currentRoom.levelId + '_' + currentRoom.roomInstanceId, JSON.stringify(state)); }
    function restoreView() { if (!currentRoom) return false; const raw = localStorage.getItem('colliderView_' + currentRoom.levelId + '_' + currentRoom.roomInstanceId); if (!raw) return false; try { const s = JSON.parse(raw); if (typeof s.zoom === 'number' && typeof s.offsetX === 'number' && typeof s.offsetY === 'number') { zoom = s.zoom; offsetX = s.offsetX; offsetY = s.offsetY; } if (Array.isArray(s.active)) { activeTypes = new Set(s.active); buildFilters(); } if (s.displayState) { Object.assign(displayState, s.displayState); syncDisplayButtons(); } return true; } catch (_) { return false; } }

    function initUi() {
            const required = ['displayToggles','btnFit','searchBtn','searchCollider','exportJson','exportPng','colliderCanvas'];
            const missing = required.filter(id => !document.getElementById(id));
            if (missing.length) {
                if (document.readyState !== 'complete') {
                    return setTimeout(initUi, 40);
                }
                console.warn('Colliders page: missing expected elements:', missing.join(','));
            }
            const displayToggles = document.getElementById('displayToggles');
            if (!displayToggles) return;
            displayToggles.addEventListener('click', e => {
                const btn = e.target.closest('button.toggle-btn');
                if (!btn) return;
                const key = btn.dataset.key;
                if (!key) return;
                displayState[key] = !displayState[key];
                btn.classList.toggle('active', displayState[key]);
                persistView();
                draw();
            });
            document.getElementById('btnFit')?.addEventListener('click', () => { fitView(); persistView(); draw(); });
            document.getElementById('searchBtn')?.addEventListener('click', () => searchCollider());
            document.getElementById('searchCollider')?.addEventListener('keydown', e => { if (e.key === 'Enter') searchCollider(); });
            document.getElementById('exportJson')?.addEventListener('click', () => { const data = JSON.stringify({ room: currentRoom, version, colliders }, null, 2); const blob = new Blob([data], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `colliders_${currentRoom?.levelId || 'unknown'}_${currentRoom?.roomInstanceId || 'x'}_v${version}.json`; a.click(); URL.revokeObjectURL(a.href); });
            document.getElementById('exportPng')?.addEventListener('click', () => { const canvas = document.getElementById('colliderCanvas'); const a = document.createElement('a'); a.href = canvas.toDataURL('image/png'); a.download = `colliders_${currentRoom?.levelId || 'unknown'}_${currentRoom?.roomInstanceId || 'x'}_v${version}.png`; a.click(); });

            const colliderCanvas = document.getElementById('colliderCanvas');
            if (!colliderCanvas) return;
            colliderCanvas.addEventListener('mousemove', onCanvasMove);
            colliderCanvas.addEventListener('click', onCanvasClick);
            colliderCanvas.addEventListener('mousedown', e => { isPanning = true; startPan = { x: e.clientX, y: e.clientY }; document.body.style.cursor = 'grabbing'; });
            colliderCanvas.addEventListener('wheel', e => { e.preventDefault(); const canvas = e.target; const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; const prevZoom = zoom; zoom *= e.deltaY < 0 ? 1.1 : 0.9; zoom = Math.min(Math.max(zoom, 0.05), 20); offsetX = mx - (mx - offsetX) * (zoom / prevZoom); offsetY = my - (my - offsetY) * (zoom / prevZoom); draw(); }, { passive: false });
            colliderCanvas.addEventListener('dblclick', () => { fitView(); draw(); });
            document.getElementById('resetView')?.addEventListener('click', () => { fitView(); draw(); });

            hub.onclose(err => {
                console.error('Collider hub closed', err);
                if (!intentionalStop) {
                    setTimeout(() => { if (pageActive && hub.state === signalR.HubConnectionState.Disconnected) hub.start().catch(e => console.error('Restart failed', e)); }, 2000);
                }
            });
            hub.onreconnecting(err => console.warn('Collider hub reconnecting...', err));
            hub.onreconnected(id => console.info('Collider hub reconnected', id));
            hub.start().then(() => { loadRooms(); resizeCanvas(); }).catch(err => console.error('Collider hub start failed', err));
            document.addEventListener('visibilitychange', () => { if (document.hidden) suspendPage(); else resumePage(); });
            window.addEventListener('beforeunload', () => { suspendPage(); });
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initUi);
        } else {
            initUi();
        }

        function searchCollider() {
            const term = document.getElementById('searchCollider').value.trim();
            if (!term) { selectedColliderId = null; document.getElementById('colliderDetail').textContent = ''; draw(); return; }
            const found = colliders.find(c => c.id.toLowerCase().includes(term.toLowerCase()));
            if (found) { selectedColliderId = found.id; document.getElementById('colliderDetail').textContent = `Selected: ${found.id} | ${found.type}`; panTo(found); draw(); }
        }
        function panTo(c) { const canvas = document.getElementById('colliderCanvas'); const cx = (c.x + c.width / 2) * scale * zoom + offsetX; const cy = (-(c.y + c.height / 2)) * scale * zoom + offsetY; const midX = canvas.width / 2; const midY = canvas.height / 2; offsetX += (midX - cx); offsetY += (midY - cy); }

    function onCanvasMove(e) {
            const canvas = e.target; const rect = canvas.getBoundingClientRect(); const mx = (e.clientX - rect.left - offsetX) / (zoom * scale); const my = -((e.clientY - rect.top - offsetY) / (zoom * scale));
            const showInactive = displayState.inactive; const showInvisible = displayState.invisible;
            const found = colliders.find(c => activeTypes.has(c.type) && (showInactive || c.active) && (showInvisible || !c.invisible) && mx >= c.x && mx <= c.x + c.width && my <= c.y && my >= c.y - c.height);
            const info = document.getElementById('hoverInfo');
            if (info) info.textContent = found ? `${found.type} ${found.id} (${found.x.toFixed(2)},${found.y.toFixed(2)}) ${found.width.toFixed(2)}x${found.height.toFixed(2)} ${found.active ? '' : '[inactive]'} ${found.invisible ? '[invis]' : ''}` : '';
        }
        function onCanvasClick(e) {
            const canvas = e.target; const rect = canvas.getBoundingClientRect(); const mx = (e.clientX - rect.left - offsetX) / (zoom * scale); const my = -((e.clientY - rect.top - offsetY) / (zoom * scale));
            const showInactive = displayState.inactive; const showInvisible = displayState.invisible;
            const found = colliders.find(c => activeTypes.has(c.type) && (showInactive || c.active) && (showInvisible || !c.invisible) && mx >= c.x && mx <= c.x + c.width && my <= c.y && my >= c.y - c.height);
            selectedColliderId = found ? found.id : null;
            const detail = document.getElementById('colliderDetail');
            if (detail) detail.textContent = found ? `Selected: ${found.id} | ${found.type} | Pos(${found.x.toFixed(2)},${found.y.toFixed(2)}) Size(${found.width.toFixed(2)}x${found.height.toFixed(2)}) Plane:${found.plane}` : '';
            draw();
        }

        window.addEventListener('mouseup', () => { isPanning = false; document.body.style.cursor = 'default'; });
        window.addEventListener('mousemove', e => { if (!isPanning) return; const dx = e.clientX - startPan.x; const dy = e.clientY - startPan.y; startPan = { x: e.clientX, y: e.clientY }; offsetX += dx; offsetY += dy; draw(); });

        function syncDisplayButtons() {
            const container = document.getElementById('displayToggles'); if (!container) return;
            [...container.querySelectorAll('button.toggle-btn')].forEach(b => {
                const key = b.dataset.key; if (!key) return; b.classList.toggle('active', !!displayState[key]);
            });
        }
    </script>
}
