@page "/rooms/colliders"
@model Web.Razor.Pages.Rooms.CollidersModel
@{
    ViewData["Title"] = "Room Colliders";
}
@section Stylesheets {
    <style>
        :root {
            --c-bg-panel: linear-gradient(145deg,#0f1f29,#142e3b 55%,#0d1a22);
            --c-border-panel: #1f4457;
            --c-border-subtle: #203c4a;
            --c-border-strong: #1d566f;
            --c-accent: #2fa8d8;
            --c-text: #e1f6ff;
            --c-text-dim: #b7d3df;
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --radius-sm: 4px;
            --radius-md: 8px;
            --shadow-panel: 0 2px 6px rgba(0,0,0,0.4), inset 0 0 10px rgba(0,0,0,0.35);
            --grad-border: linear-gradient(140deg,rgba(47,168,216,.9),rgba(47,168,216,0) 60%);
            --surface-glass: rgba(20,46,59,0.55);
            --surface-glass-solid: rgba(20,46,59,0.85);
            --warn: #ffb347;
            --danger: #ff6b6b;
            --ok: #4ecdc4;
            --focus-ring: 0 0 0 2px rgba(47,168,216,.9),0 0 12px -2px rgba(47,168,216,.8);
        }

    #colliderCanvas { width:100%; height:70vh; border:1px solid #1d4150; background:radial-gradient(circle at 35% 40%, #0e2735 0%, #081923 60%, #06151d 100%); cursor:grab; border-radius:18px; box-shadow:0 0 0 1px #0d2631, 0 6px 26px -6px rgba(0,0,0,0.55), inset 0 0 42px -8px rgba(0,160,210,0.25); position:relative; }
        .canvas-wrapper { position:relative; }
    .status-group { display:flex; flex-wrap:wrap; gap:var(--space-2); margin-top:var(--space-2); align-items:center; }
        #status, #stats, #hoverInfo, #colliderDetail { background:rgba(25,40,50,0.55); backdrop-filter:blur(2px); border:1px solid rgba(90,170,200,0.35); border-radius:var(--radius-sm); padding:2px 6px; color:#e8f7ff !important; font-weight:500; text-shadow:0 0 3px rgba(0,0,0,0.7); }
        .auto-hide:empty { display:none !important; }
    #hoverInfo { margin-top:0; }
    #roomList { max-height:28vh; overflow-y:auto; overflow-x:hidden; border:1px solid var(--c-border-subtle); border-radius:var(--radius-sm); scroll-behavior:smooth; }
        .collider-item { font-size:12px; line-height:1.15; padding:4px 8px; }
        #roomList .list-group-item.collider-item { background:#133043; color:#f0f6fc; border:0; border-bottom:1px solid #0f2735; }
        #roomList .list-group-item.collider-item:last-child { border-bottom:0; }
        #roomList .list-group-item.collider-item:hover { background:#19465f; color:#ffffff; }
        #roomList .list-group-item.collider-item.active-room { background:#256d8f; color:#fff; font-weight:600; }

    .collider-side { position:sticky; top:var(--space-3); background:linear-gradient(160deg,#112836,#0f2430 45%,#0a1b23); border:1px solid #1d4254; border-radius:18px; padding:20px 18px 22px; box-shadow:0 4px 18px -4px rgba(0,0,0,0.6), inset 0 0 0 1px rgba(255,255,255,0.03); display:flex; flex-direction:column; gap:18px; font-size:13px; backdrop-filter:blur(4px) saturate(130%); position:relative; overflow:hidden; }
    .collider-side:before { content:""; position:absolute; inset:0; pointer-events:none; background:radial-gradient(circle at 15% 12%,rgba(47,168,216,.15),transparent 60%), radial-gradient(circle at 80% 85%,rgba(47,168,216,.08),transparent 70%); mix-blend-mode:screen; opacity:.8; }
    .collider-side:after { content:""; position:absolute; inset:0; padding:1px; border-radius:inherit; background:linear-gradient(155deg,rgba(47,168,216,.55),rgba(47,168,216,0) 40%,rgba(47,168,216,.4)); -webkit-mask:linear-gradient(#000 0 0) content-box,linear-gradient(#000 0 0); -webkit-mask-composite:xor; mask-composite:exclude; pointer-events:none; }
    .collider-side h5.page-title { margin:0 0 var(--space-1); color:#f5fbff; font-weight:600; letter-spacing:.5px; text-shadow:0 1px 2px #000; font-size:1.1rem; display:flex; align-items:center; gap:6px; }
    .panel-section { display:flex; flex-direction:column; gap:var(--space-2); }
    .panel-section + .panel-section { border-top:1px solid rgba(255,255,255,0.05); padding-top:var(--space-3); }
    .panel-section h5 { margin:0; color:#f5fbff; font-weight:600; font-size:.9rem; letter-spacing:.5px; display:flex; align-items:center; gap:6px; }
    .panel-section h6 { margin:0; color:#d6ecf5; font-weight:600; font-size:.7rem; letter-spacing:.75px; text-transform:uppercase; opacity:.85; }
    .panel-section.primary h5 { position:relative; padding-left:10px; }
    .panel-section.primary h5:before { content:""; position:absolute; left:0; top:50%; transform:translateY(-50%); width:4px; height:60%; background:var(--c-accent); border-radius:2px; box-shadow:0 0 6px rgba(47,168,216,.6); }
        .panel-small { font-size:11px; color:var(--c-text-dim); }
        .legend { display:grid; grid-template-columns:repeat(auto-fill,minmax(70px,1fr)); gap:4px; }
        .legend span { display:inline-flex; align-items:center; justify-content:center; padding:2px 4px; border-radius:var(--radius-sm); font-size:10px; line-height:1.1; border:1px solid rgba(255,255,255,0.12); background:#1a2f3b; color:#dff7ff; font-weight:500; }
        .filter-swatch { display:inline-block; width:14px; height:14px; border:1px solid rgba(0,0,0,0.55); margin-right:4px; border-radius:3px; box-shadow:0 0 0 1px rgba(0,0,0,0.6), 0 0 4px rgba(0,0,0,0.5); }
        #filterList { display:grid; grid-template-columns:repeat(auto-fill,minmax(120px,1fr)); gap:2px 6px; }
        #filterList .form-check { padding:2px 2px; margin:0; display:flex; align-items:center; gap:6px; background:#123040; border:1px solid #1d4558; border-radius:var(--radius-sm); }
        #filterList .form-check:hover { background:#16495e; }
        #filterList .form-check-input { margin:0; position:static; width:16px; height:16px; cursor:pointer; background:#1b3643; border:1px solid #2a5f77; }
        #filterList .form-check-input:checked { background:var(--c-accent); border-color:var(--c-accent); }
        #filterList label { cursor:pointer; user-select:none; display:flex; align-items:center; gap:6px; margin:0; font-size:11px; color:var(--c-text); }
    .btn-outline-dark, .btn-light { background:linear-gradient(145deg,#15394a,#132f3d); color:#e0f8ff; border:1px solid #1e5166; border-radius:10px; font-weight:500; letter-spacing:.3px; position:relative; overflow:hidden; }
    .btn-outline-dark::after, .btn-light::after { content:""; position:absolute; inset:0; background:linear-gradient(120deg,rgba(255,255,255,0.08),rgba(255,255,255,0)); opacity:0; transition:opacity .25s; }
    .btn-outline-dark:hover::after, .btn-light:hover::after { opacity:1; }
    .btn-outline-dark:hover, .btn-light:hover, .btn-outline-dark.active { background:linear-gradient(145deg,#1d566f,#194c63); color:#fff; box-shadow:0 0 0 1px #226d8a, 0 0 8px -1px rgba(47,168,216,0.5); }
        .form-check-input { background:#1b3643; border:1px solid #2a5f77; }
        .form-check-input:checked { background:var(--c-accent); border-color:var(--c-accent); }
    .input-group-sm > .form-control { background:#123040; border:1px solid var(--c-border-strong); color:var(--c-text); }
    .input-group-sm > .form-control:focus { background:#163b4d; color:#fff; }
    .input-group-sm .btn { background:#123040; border:1px solid var(--c-border-strong); color:var(--c-text); }
    .input-group-sm .btn:hover { background:#1d566f; color:#fff; }
    .input-group-sm .form-control, .input-group-sm .btn { height:30px; }
    .section-inline-controls { display:flex; flex-wrap:wrap; gap:6px; }
    #displayToggles button.toggle-btn, #displayToggles #btnFit { min-width:56px; font-size:11px; padding:4px 10px; line-height:1.1; border-radius:12px; transition:background .25s, box-shadow .25s, transform .35s cubic-bezier(.34,1.56,.3,1); position:relative; }
    #displayToggles button.toggle-btn.active { background:linear-gradient(145deg,#2186ab,#1c6f8d); box-shadow:0 0 0 1px #2fa8d8, 0 0 10px -2px rgba(47,168,216,0.7); transform:translateY(-2px); }
    #displayToggles button.toggle-btn:focus-visible { outline:none; box-shadow:var(--focus-ring); }
    #displayToggles button.toggle-btn:not(.active):hover, #displayToggles #btnFit:hover { background:#19465f; }
    #displayHint { color:#7fbfd6; font-size:10px; margin-top:4px; text-shadow:0 0 4px rgba(0,0,0,0.4); }

    .search-group { display:flex; align-items:stretch; width:100%; background:linear-gradient(135deg,#133544,#0f2935); border:1px solid #1e5166; border-radius:14px; overflow:hidden; box-shadow:0 4px 14px -6px rgba(0,0,0,0.6), inset 0 0 0 1px rgba(255,255,255,0.03); }
    .search-group input { background:transparent; border:0; color:#dff7ff; padding:8px 14px; font-size:12px; flex:1; outline:none; }
    .search-group input::placeholder { color:#5d8897; }
    .search-group button { background:linear-gradient(145deg,#1d566f,#1a4e63); border:0; color:#e6fbff; padding:0 20px; display:flex; align-items:center; justify-content:center; font-size:11px; font-weight:600; cursor:pointer; letter-spacing:.5px; }
    .search-group button:hover { background:linear-gradient(145deg,#227797,#1d6078); }
    .search-group button:active { transform:translateY(1px); }

    #roomList .collider-item { --pill-line-height:16px; font-size:12px; line-height:var(--pill-line-height); border-radius:10px; margin:2px 4px; background:linear-gradient(145deg,#132f3f,#102633); border:1px solid #1a4558; transition:background .25s, transform .25s, box-shadow .25s, opacity .28s ease, max-height .28s ease, padding .28s ease, margin .28s ease; display:block; white-space:normal; word-break:break-word; overflow-wrap:anywhere; padding:4px 8px; font-weight:500; position:relative; }
    #roomList .collider-item.fade-out { opacity:0; transform:translateX(-6px); pointer-events:none; }
    #roomList .collider-item:hover { background:#19465f; transform:translateY(-1px); line-height:var(--pill-line-height); }
    #roomList .collider-item.active-room { background:linear-gradient(145deg,#256d8f,#1d5a77); box-shadow:0 0 0 1px #2fa8d8, 0 0 10px -2px rgba(47,168,216,.6); font-weight:600; line-height:var(--pill-line-height); }

    #roomList::-webkit-scrollbar { width:10px; }
    #roomList::-webkit-scrollbar-track { background:#0f2531; border-radius:8px; }
    #roomList::-webkit-scrollbar-thumb { background:linear-gradient(#1f566c,#1b4d61); border-radius:8px; border:2px solid #0f2531; }
    #roomList::-webkit-scrollbar-thumb:hover { background:linear-gradient(#276f8a,#236175); }

    .status-group > div { border-radius:14px !important; padding:4px 10px !important; background:linear-gradient(135deg,rgba(32,74,92,0.65),rgba(18,50,64,0.65)); backdrop-filter:blur(4px); box-shadow:0 0 0 1px rgba(47,168,216,0.25), 0 4px 14px -6px rgba(0,0,0,.65); position:relative; overflow:hidden; }
    .status-group > div:before { content:""; position:absolute; inset:0; background:linear-gradient(120deg,rgba(47,168,216,.25),rgba(47,168,216,0) 65%); mix-blend-mode:overlay; opacity:.25; pointer-events:none; }
    #hoverInfo { font-weight:500; }
    .canvas-wrapper:focus-within #colliderCanvas { outline:2px solid var(--c-accent); outline-offset:4px; }
        ul.compact-list { list-style:disc; padding-left:16px; margin:0; display:flex; flex-direction:column; gap:2px; }
        ul.compact-list li { color:#d6ecf5; font-size:11px; }
        .export-group .btn { flex:1; }
        .collider-side #colliderDetail { min-height:18px; }
        .canvas-wrapper:focus-within #colliderCanvas { outline:2px solid var(--c-accent); }

    .visually-hidden { position:absolute !important; width:1px !important; height:1px !important; padding:0 !important; margin:-1px !important; overflow:hidden !important; clip:rect(0 0 0 0) !important; border:0 !important; white-space:nowrap !important; }

    #roomsSidebar { transition:max-height .5s ease, padding .35s ease, opacity .4s ease; }
    #roomsSidebar.collapsed { max-height:0 !important; padding:0 0 !important; opacity:0; overflow:hidden; border-width:0; box-shadow:none; }
    @@media (max-width: 991.98px) {
        .collider-side { position:relative; top:0; }
        #colliderCanvas { height:60vh; }
        .status-group { margin-top:12px; }
    }

    .canvas-wrapper { border-radius:22px; position:relative; overflow:hidden; box-shadow:0 10px 34px -12px rgba(0,0,0,.65),0 0 0 1px #10313f, inset 0 0 0 1px rgba(255,255,255,0.02); }
    .canvas-wrapper:before { content:""; position:absolute; inset:0; background:radial-gradient(circle at 25% 20%,rgba(47,168,216,.08),transparent 70%), radial-gradient(circle at 80% 75%,rgba(47,168,216,.05),transparent 75%); pointer-events:none; mix-blend-mode:screen; }

    #roomList .collider-item { position:relative; }
    #roomList .collider-item.active-room:after { content:""; position:absolute; inset:0; border-radius:10px; padding:1px; background:linear-gradient(140deg,rgba(47,168,216,.8),rgba(47,168,216,0) 55%); -webkit-mask:linear-gradient(#000 0 0) content-box,linear-gradient(#000 0 0); -webkit-mask-composite:xor; mask-composite:exclude; pointer-events:none; }

    #filterList .form-check-input { transition:background .3s, transform .35s cubic-bezier(.34,1.56,.3,1); }
    #filterList .form-check-input:checked { transform:scale(1.1); }

    .export-group .btn { position:relative; overflow:hidden; }
    .export-group .btn:before { content:""; position:absolute; inset:0; background:radial-gradient(circle at 30% 20%,rgba(255,255,255,.15),transparent 70%); opacity:0; transition:opacity .35s; pointer-events:none; }
    .export-group .btn:hover:before { opacity:1; }

    @@keyframes pulseFlash { 0%{box-shadow:0 0 0 0 rgba(47,168,216,.7);} 70%{box-shadow:0 0 0 8px rgba(47,168,216,0);} 100%{box-shadow:0 0 0 0 rgba(47,168,216,0);} }
    .pulse-once { animation:pulseFlash 1.2s ease forwards; }

    @@media (prefers-contrast: more) { #colliderCanvas { outline:2px solid #fff; } }

    @@media (prefers-reduced-motion: reduce) {
        * { transition:none !important; animation:none !important; }
    }
    </style>
}
<div class="container-fluid mt-3">
    <div class="row">
        <div class="col-md-3">
            <button class="btn btn-outline-dark w-100 d-md-none mb-2" id="toggleSidebar" type="button" aria-expanded="true" aria-controls="roomsSidebar">Hide Panel</button>
            <div class="collider-side" id="roomsSidebar" role="complementary" aria-label="Colliders sidebar">
                <h5 class="page-title">@ViewData["ServerName"] Rooms</h5>

                <div class="panel-section primary" aria-labelledby="rooms-heading">
                    <h5 id="rooms-heading">Rooms</h5>
                    <div id="roomList" class="list-group"></div>
                </div>

                <div class="panel-section primary" aria-labelledby="filters-heading">
                    <h5 id="filters-heading">Filters</h5>
                    <div id="filterList"></div>
                </div>

                <div class="panel-section primary" aria-labelledby="planes-heading">
                    <h5 id="planes-heading">Planes</h5>
                    <div id="planeToggles" class="section-inline-controls" style="gap:6px; flex-wrap:wrap;" aria-label="Plane selection (single)"></div>
                    <div class="panel-small" id="planeHint">Select a plane to view (single selection).</div>
                </div>

                <div class="panel-section primary" aria-labelledby="display-heading">
                    <h5 id="display-heading">Display</h5>
                    <div class="section-inline-controls" id="displayToggles" style="gap:6px; flex-wrap:wrap;">
                        <button id="btnFit" class="btn btn-sm btn-outline-dark toggle-btn" data-role="action" title="Fit current room bounds (F)">Fit</button>
                        <button data-key="autoFit" class="btn btn-sm btn-outline-dark toggle-btn active" title="Auto-fit when bounds expand">Auto</button>
                        <button data-key="bbox" class="btn btn-sm btn-outline-dark toggle-btn" title="Show room bounding box">BBox</button>
                        <button data-key="grid" class="btn btn-sm btn-outline-dark toggle-btn active" title="Show grid">Grid</button>
                        <button data-key="flash" class="btn btn-sm btn-outline-dark toggle-btn active" title="Flash changed colliders">Flash</button>
                        <button data-key="inactive" class="btn btn-sm btn-outline-dark toggle-btn active" title="Show inactive colliders">Inactive</button>
                        <button data-key="invisible" class="btn btn-sm btn-outline-dark toggle-btn active" title="Show invisible colliders (faded)">Invisible</button>
                    </div>
                    <div class="panel-small" id="displayHint">Flash highlights new/updated shapes for 1.5s.</div>
                </div>

                <div class="panel-section" aria-labelledby="search-heading">
                    <h5 id="search-heading">Search</h5>
                    <div class="search-group" role="search">
                        <input type="text" id="searchCollider" placeholder="Collider id..." aria-label="Collider search" />
                        <button id="searchBtn" title="Find collider by ID">FIND</button>
                    </div>
                </div>

                <div class="panel-section export-group" aria-labelledby="export-heading">
                    <h5 id="export-heading">Export</h5>
                    <div class="btn-group btn-group-sm w-100" role="group">
                        <button id="exportJson" class="btn btn-outline-dark" title="Download collider list as JSON">JSON</button>
                        <button id="exportPng" class="btn btn-outline-dark" title="Download canvas as PNG">PNG</button>
                    </div>
                </div>

                <div class="panel-section" aria-labelledby="controls-heading">
                    <h5 id="controls-heading">Controls</h5>
                    <ul class="compact-list">
                        <li>Drag to pan</li>
                        <li>Scroll to zoom</li>
                        <li>Double-click to reset view</li>
                    </ul>
                    <div id="colliderDetail" class="small auto-hide mt-1" aria-label="Collider details"></div>
                </div>
            </div>
        </div>
        <div class="col-md-9">
            <div class="canvas-wrapper" aria-live="off">
                <canvas id="colliderCanvas" aria-label="Collider visualization" tabindex="0"></canvas>
            </div>
            <div class="status-group">
                <div id="status" class="small" role="status" aria-live="polite"></div>
                <div id="viewerCount" class="small auto-hide" role="status" aria-live="polite"></div>
                <div id="stats" class="small auto-hide" role="status" aria-live="polite"></div>
                <div id="hoverInfo" class="small auto-hide" aria-live="polite"></div>
                <div id="srAnnounce" class="visually-hidden" aria-live="polite" aria-atomic="true"></div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/@@microsoft/signalr@8.0.0/dist/browser/signalr.min.js" referrerpolicy="no-referrer"></script>
    <script>
    const hub = new signalR.HubConnectionBuilder().withUrl('/hubs/colliders').withAutomaticReconnect().build();
        let rooms = []; let currentRoom = null; let colliders = []; let scale = 32; // world units to pixels
        let zoom = 1; let offsetX = 0; let offsetY = 0; let isPanning = false; let startPan = { x: 0, y: 0 };
        const colors = { Attack: '#ff6b6b', Player: '#4ecdc4', Enemy: '#ffe66d', Default: '#1a535c', Breakable: '#a29bfe', Hazard: '#ff922b', MovingPlatform: '#74c0fc', TriggerTarget: '#e599f7', TriggerReceiver: '#be4bdb', Stomper: '#ff8787', AiAttack: '#ff6b6b' };
        let activeTypes = new Set(Object.keys(colors));
        let version = 0;
        const changeFlash = new Map();
        const FLASH_MS = 1500;
        let lastBbox = null;
        let pendingStats = null;
        const displayState = {
            autoFit: true,
            bbox: false,
            grid: true,
            flash: true,
            inactive: true,
            invisible: true
        };
        let activePlanes = new Set();
        let knownPlanes = [];
        let hoverStack = [];
        let lastClickStack = null; // { ids:Set<string>, index:number, time:number }
        let lastHoverTopId = null;
        let selectedColliderId = null;
        let currentSubscriberCount = 0;
        let fpsFrameCount = 0; let fpsLastTime = performance.now(); let fps = 0;
        let pageActive = true;
        let intentionalStop = false;
        let initialized = false;

        function normalizeCollider(c) {
            if (!c) return c;
            let plane = c.plane ?? c.Plane ?? 0;
            if (typeof plane === 'string') {
                // Extract first integer, e.g. "Plane0" -> 0, "1" -> 1
                const m = plane.match(/(\d+)/);
                plane = m ? parseInt(m[1], 10) : 0;
            }
            if (!Number.isFinite(plane)) plane = 0;
            return {
                ...c,
                id: c.id ?? c.Id ?? '',
                type: c.type ?? c.Type ?? 'Default',
                active: (c.active ?? c.Active ?? true),
                invisible: (c.invisible ?? c.Invisible ?? false),
                plane,
                x: c.x,
                y: c.y,
                width: c.width,
                height: c.height
            };
        }

    function fitView() {
            if (colliders.length === 0) return;
            const minX = Math.min(...colliders.map(c => c.x));
            const minY = Math.min(...colliders.map(c => c.y));
            const maxX = Math.max(...colliders.map(c => c.x + c.width));
            const maxY = Math.max(...colliders.map(c => c.y + c.height));
            const canvas = document.getElementById('colliderCanvas');
            const padding = 2;
            const w = maxX - minX + padding * 2; const h = maxY - minY + padding * 2;
            zoom = Math.min(canvas.width / (w * scale), canvas.height / (h * scale));
            offsetX = -(minX - padding) * scale * zoom + (canvas.width - w * scale * zoom) / 2;
            offsetY = -(minY - padding) * scale * zoom + (canvas.height - h * scale * zoom) / 2;
        }

    function draw() {
            if (!pageActive) return;
            const frameStart = performance.now();
            const canvas = document.getElementById('colliderCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);
            // Grid (unchanged)
            if (displayState.grid) {
                ctx.save();
                const gridSize = scale;
                const visibleWorldW = canvas.width / (zoom * scale);
                const visibleWorldH = canvas.height / (zoom * scale);
                const centerWorldX = ((canvas.width / 2) - offsetX) / (zoom * scale);
                const centerWorldY = -(((canvas.height / 2) - offsetY) / (zoom * scale));
                const minX = Math.floor(centerWorldX - visibleWorldW / 2) - 2;
                const maxX = Math.ceil(centerWorldX + visibleWorldW / 2) + 2;
                const minY = Math.floor(centerWorldY - visibleWorldH / 2) - 2;
                const maxY = Math.ceil(centerWorldY + visibleWorldH / 2) + 2;
                ctx.lineWidth = 1 / zoom;
                for (let x = minX; x <= maxX; x++) { ctx.beginPath(); ctx.strokeStyle = (x % 5 === 0) ? 'rgba(90,170,200,0.25)' : 'rgba(40,90,115,0.35)'; ctx.moveTo(x * gridSize, -(minY) * gridSize); ctx.lineTo(x * gridSize, -(maxY) * gridSize); ctx.stroke(); }
                for (let y = minY; y <= maxY; y++) { ctx.beginPath(); ctx.strokeStyle = (y % 5 === 0) ? 'rgba(90,170,200,0.25)' : 'rgba(40,90,115,0.35)'; ctx.moveTo(minX * gridSize, -y * gridSize); ctx.lineTo(maxX * gridSize, -y * gridSize); ctx.stroke(); }
                ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth = 1.5 / zoom; ctx.beginPath(); ctx.moveTo(0, -(minY) * gridSize); ctx.lineTo(0, -(maxY) * gridSize); ctx.stroke(); ctx.beginPath(); ctx.moveTo(minX * gridSize, 0); ctx.lineTo(maxX * gridSize, 0); ctx.stroke(); ctx.restore();
            }
            const now = performance.now();
            const showInactive = displayState.inactive;
            const showInvisible = displayState.invisible;
            // Visible bounds (world)
            const visibleMinX = (0 - offsetX) / (zoom * scale);
            const visibleMaxX = (canvas.width - offsetX) / (zoom * scale);
            const visibleMaxY = -((0 - offsetY) / (zoom * scale));
            const visibleMinY = -((canvas.height - offsetY) / (zoom * scale));
            // Adaptive flash quality
            if (!window._flashState) window._flashState = { quality: 'high', lastMs: 0 };
            const s = window._flashState;
            if (colliders.length > 1500 || zoom < 0.28 || s.lastMs > 28) s.quality = 'low';
            else if (s.lastMs < 18 && colliders.length < 1200 && zoom >= 0.32) s.quality = 'high';
            let flashedCount = 0;
            for (const c of colliders) {
                if (!activeTypes.has(c.type)) continue;
                if (!showInactive && !c.active) continue;
                if (!showInvisible && c.invisible) continue;
                if (activePlanes.size && !activePlanes.has(c.plane)) continue;
                if (c.x + c.width < visibleMinX || c.x > visibleMaxX || c.y + c.height < visibleMinY || c.y > visibleMaxY) continue; // cull
                const color = colors[c.type] || colors.Default;
                let baseColor = c.active ? color : '#555';
                const t = changeFlash.get(c.id);
                let flashing = false;
                if (displayState.flash && t && now - t < FLASH_MS) {
                    const alpha = 1 - (now - t) / FLASH_MS;
                    if (s.quality === 'high' && flashedCount < 650) ctx.fillStyle = brightenColor(baseColor, alpha); else ctx.fillStyle = shadeColor(baseColor, alpha * 120);
                    flashedCount++; flashing = true;
                } else ctx.fillStyle = baseColor;
                ctx.globalAlpha = c.invisible ? 0.3 : 0.8;
                ctx.fillRect(c.x * scale, (-(c.y + c.height)) * scale, c.width * scale, c.height * scale);
                ctx.globalAlpha = 1.0;
                if (flashing) {
                    const alpha = 1 - (now - t) / FLASH_MS;
                    if (s.quality === 'high' && flashedCount < 700) { ctx.save(); ctx.strokeStyle = `rgba(255,255,255,${Math.min(1, alpha*0.9)})`; ctx.lineWidth = 3 / zoom; ctx.shadowBlur = 10 / zoom; ctx.shadowColor = 'rgba(255,255,255,0.55)'; ctx.strokeRect(c.x * scale, (-(c.y + c.height)) * scale, c.width * scale, c.height * scale); ctx.restore(); }
                    else { ctx.save(); ctx.strokeStyle = `rgba(255,255,255,${Math.min(0.9, alpha)})`; ctx.lineWidth = 1.5 / zoom; ctx.strokeRect(c.x * scale, (-(c.y + c.height)) * scale, c.width * scale, c.height * scale); ctx.restore(); }
                } else { ctx.save(); ctx.strokeStyle = '#222'; ctx.lineWidth = 1 / zoom; ctx.strokeRect(c.x * scale, (-(c.y + c.height)) * scale, c.width * scale, c.height * scale); ctx.restore(); }
                if (selectedColliderId === c.id) { ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 2 / zoom; ctx.strokeRect(c.x * scale, (-(c.y + c.height)) * scale, c.width * scale, c.height * scale); }
            }
            if (hoverStack.length) {
                const top = hoverStack[0];
                if (top) {
                    ctx.save();
                    ctx.strokeStyle = '#ffffff';
                    ctx.setLineDash([6 / zoom, 4 / zoom]);
                    ctx.lineWidth = 2 / zoom;
                    ctx.strokeRect(top.x * scale, (-(top.y + top.height)) * scale, top.width * scale, top.height * scale);
                    ctx.restore();
                    if (hoverStack.length > 1) {
                        ctx.save();
                        const badgeX = top.x * scale;
                        const badgeY = (-(top.y + top.height)) * scale; // top-left screen position
                        const pad = 4;
                        const txt = hoverStack.length.toString();
                        ctx.font = `${12}px system-ui,sans-serif`;
                        const tw = ctx.measureText(txt).width;
                        const bw = tw + pad * 2;
                        const bh = 16;
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.strokeStyle = '#ffd54f';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        const r = 6;
                        const bx = badgeX + 2;
                        const by = badgeY + 2;
                        // Rounded rect
                        ctx.moveTo(bx + r, by);
                        ctx.lineTo(bx + bw - r, by);
                        ctx.quadraticCurveTo(bx + bw, by, bx + bw, by + r);
                        ctx.lineTo(bx + bw, by + bh - r);
                        ctx.quadraticCurveTo(bx + bw, by + bh, bx + bw - r, by + bh);
                        ctx.lineTo(bx + r, by + bh);
                        ctx.quadraticCurveTo(bx, by + bh, bx, by + bh - r);
                        ctx.lineTo(bx, by + r);
                        ctx.quadraticCurveTo(bx, by, bx + r, by);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#ffd54f';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(txt, bx + pad, by + bh / 2);
                        ctx.restore();
                    }
                }
            }
            if (displayState.bbox && lastBbox) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.setLineDash([6 / zoom, 4 / zoom]);
                ctx.lineWidth = 1.5 / zoom;
                ctx.strokeRect(lastBbox.minX * scale, (-(lastBbox.minY + lastBbox.height)) * scale, lastBbox.width * scale, lastBbox.height * scale);
                ctx.restore();
            }
            ctx.restore();
            document.getElementById('status').innerText = currentRoom ? `${currentRoom.name} | V${version} | Colliders: ${colliders.length} | Zoom: ${zoom.toFixed(2)} | FPS: ${fps.toFixed(0)} | Flash:${window._flashState?.quality || 'high'}` : 'No room selected';
            const vcEl = document.getElementById('viewerCount');
            if (vcEl) {
                if (currentRoom) {
                    vcEl.textContent = `Viewers: ${currentSubscriberCount}`;
                } else {
                    vcEl.textContent = '';
                }
            }
            if (pendingStats) { const statsEl = document.getElementById('stats'); if (statsEl) statsEl.innerText = `Δ Added:${pendingStats.added} Updated:${pendingStats.updated} Removed:${pendingStats.removed} Bounds: ${pendingStats.bbox.width.toFixed(1)}x${pendingStats.bbox.height.toFixed(1)}`; pendingStats = null; }
            if (pageActive && ((displayState.flash && changeFlash.size > 0) || selectedColliderId)) scheduleNextFrame();
            fpsFrameCount++; const nowTs = performance.now(); if (nowTs - fpsLastTime >= 1000) { fps = (fpsFrameCount * 1000) / (nowTs - fpsLastTime); fpsFrameCount = 0; fpsLastTime = nowTs; }
            window._flashState.lastMs = performance.now() - frameStart;
        }
        const MAX_FPS = 30; let lastFrameTs = 0;
        function scheduleNextFrame() {
            if (!pageActive) return;
            requestAnimationFrame(ts => {
                if (!pageActive) return;
                if (ts - lastFrameTs >= 1000 / MAX_FPS) {
                    lastFrameTs = ts;
                    draw();
                } else if (changeFlash.size > 0 || selectedColliderId) {
                    scheduleNextFrame();
                }
            });
        }

        function suspendPage() {
            if (!pageActive) return; 
            pageActive = false;
            changeFlash.clear();
            try {
                if (hub && hub.state !== signalR.HubConnectionState.Disconnected) {
                    intentionalStop = true;
                    hub.stop().catch(() => { /* ignore */ });
                }
            } catch (_) { /* noop */ }
        }

        function resumePage() {
            if (pageActive) return;
            pageActive = true;
            intentionalStop = false;
            const restartNeeded = hub && hub.state === signalR.HubConnectionState.Disconnected;
            if (restartNeeded) {
                hub.start().then(() => {
                    if (currentRoom) {
                        return hub.invoke('SubscribeRoom', currentRoom.levelId, currentRoom.roomInstanceId)
                            .then(data => {
                                if (data) {
                                    colliders = (data.colliders || data.Colliders || []).map(normalizeCollider);
                                    version = data.version || version;
                                    lastBbox = data.bbox || lastBbox;
                                }
                                draw();
                            });
                    } else {
                        loadRooms();
                        draw();
                    }
                }).catch(err => console.error('Resume hub start failed', err));
            } else {
                draw();
            }
            scheduleNextFrame();
        }

        function shadeColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            let r = (num >> 16) + percent;
            let g = ((num >> 8) & 0x00FF) + percent;
            let b = (num & 0x0000FF) + percent;
            r = Math.min(255, Math.max(0, r)); g = Math.min(255, Math.max(0, g)); b = Math.min(255, Math.max(0, b));
            return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
        }

        function brightenColor(hex, intensity) {
            // intensity 0..1, move color toward white non-linearly
            const num = parseInt(hex.replace('#',''),16);
            let r = (num >> 16) & 0xFF;
            let g = (num >> 8) & 0xFF;
            let b = num & 0xFF;
            const k = Math.pow(intensity, 0.6); // slower falloff
            r = Math.round(r + (255 - r) * k);
            g = Math.round(g + (255 - g) * k);
            b = Math.round(b + (255 - b) * k);
            return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6,'0');
        }

        function resizeCanvas() {
            const canvas = document.getElementById('colliderCanvas');
            if (!canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            canvas.width = Math.round(displayWidth * dpr);
            canvas.height = Math.round(displayHeight * dpr);
            const ctx = canvas.getContext('2d');
            ctx.setTransform(1,0,0,1,0,0);
            ctx.scale(dpr, dpr);
            draw();
        }

        window.addEventListener('resize', () => { resizeCanvas(); fitView(); draw(); });

        function buildFilters() {
            const container = document.getElementById('filterList');
            container.innerHTML = '';
            Object.keys(colors).forEach(t => {
                const id = 'flt_' + t;
                const swatch = colors[t] || '#1a535c';
                const div = document.createElement('div');
                div.className = 'form-check';
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'form-check-input';
                input.id = id;
                input.checked = activeTypes.has(t);
                const label = document.createElement('label');
                label.className = 'form-check-label small';
                label.setAttribute('for', id);
                const span = document.createElement('span');
                span.className = 'filter-swatch';
                span.style.background = swatch;
                label.appendChild(span);
                label.appendChild(document.createTextNode(t));
                div.appendChild(input);
                div.appendChild(label);
                container.appendChild(div);
                input.addEventListener('change', e => { if (e.target.checked) activeTypes.add(t); else activeTypes.delete(t); draw(); });
            });
        }

        async function loadRooms() {
            rooms = await hub.invoke('GetRooms'); const list = document.getElementById('roomList'); list.innerHTML = '';
            rooms.forEach(r => {
                 const a = document.createElement('a');
                 a.href = '#';
                 a.className = 'list-group-item list-group-item-action collider-item';
                 const levelId = r.levelId ?? r.LevelId ?? '?';
                 const roomInstanceId = r.roomInstanceId ?? r.RoomInstanceId ?? '?';
                 const name = r.name ?? r.Name ?? 'Unnamed';
                 a.textContent = `${levelId}:${roomInstanceId} ${name}`;
                 a.dataset.levelId = levelId;
                 a.dataset.roomInstanceId = roomInstanceId;
                 a.onclick = (e) => { e.preventDefault(); selectRoom(r); highlightActiveRoom(levelId, roomInstanceId); };
                 list.appendChild(a);
            });
            buildFilters();
             if (currentRoom) highlightActiveRoom(currentRoom.levelId, currentRoom.roomInstanceId);
         }

    async function selectRoom(r) {
            if (currentRoom) await hub.invoke('UnsubscribeRoom', currentRoom.levelId, currentRoom.roomInstanceId);
            currentRoom = { levelId: r.levelId ?? r.LevelId, roomInstanceId: r.roomInstanceId ?? r.RoomInstanceId, name: r.name ?? r.Name ?? 'Unnamed' };
            const detailEl = document.getElementById('colliderDetail'); if (detailEl) detailEl.textContent='';
            const statsEl = document.getElementById('stats'); if (statsEl) statsEl.textContent='';
            const hoverEl = document.getElementById('hoverInfo'); if (hoverEl) hoverEl.textContent='';
            const data = await hub.invoke('SubscribeRoom', currentRoom.levelId, currentRoom.roomInstanceId);
            try { currentSubscriberCount = await hub.invoke('GetSubscriberCount', currentRoom.levelId, currentRoom.roomInstanceId); } catch (_) { currentSubscriberCount = 0; }
            if (data) {
                colliders = (data.colliders || data.Colliders || []).map(normalizeCollider);
                version = data.version || 0;
                lastBbox = data.bbox || null;
                changeFlash.clear();
                colliders.forEach(c => changeFlash.set(c.id, performance.now()));
                rebuildPlanes();
                const restored = restoreView();
                if (!restored) {
                    fitView();
                }
                persistView();
                highlightActiveRoom(currentRoom.levelId, currentRoom.roomInstanceId);
                draw();
                announce(`Room ${currentRoom.name} loaded with ${colliders.length} colliders. Version ${version}.`);
            }
        }
        function highlightActiveRoom(levelId, roomInstanceId) {
            const list = document.getElementById('roomList'); if (!list) return;
            [...list.querySelectorAll('.collider-item')].forEach(a => a.classList.toggle('active-room', a.dataset.levelId == levelId && a.dataset.roomInstanceId == roomInstanceId));
        }

    hub.on('collidersUpdated', payload => { if (!currentRoom) return; if (payload.levelId === currentRoom.levelId && payload.roomInstanceId === currentRoom.roomInstanceId) { colliders = (payload.colliders || []).map(normalizeCollider); version = payload.version || version + 1; lastBbox = payload.bbox || lastBbox; if (rebuildPlanes()) persistView(); fitView(); persistView(); draw(); } });
    hub.on('roomSubscriberCount', payload => {
        if (currentRoom && payload.levelId === currentRoom.levelId && payload.roomInstanceId === currentRoom.roomInstanceId) {
            currentSubscriberCount = payload.count || 0;
            const vc = document.getElementById('viewerCount');
            if (vc) vc.textContent = `Viewers: ${currentSubscriberCount}`;
        }
    });
    hub.on('collidersReset', payload => { if (!currentRoom) return; if (payload.levelId === currentRoom.levelId && payload.roomInstanceId === currentRoom.roomInstanceId) { colliders = (payload.colliders || []).map(normalizeCollider); version = payload.version || 0; lastBbox = payload.bbox || null; changeFlash.clear(); colliders.forEach(c => changeFlash.set(c.id, performance.now())); rebuildPlanes(); fitView(); persistView(); draw(); } });
        hub.on('collidersDiff', payload => {
            if (!currentRoom) return;
            if (payload.levelId !== currentRoom.levelId || payload.roomInstanceId !== currentRoom.roomInstanceId) return;
            if (payload.version && payload.version <= version) return; // stale
            version = payload.version || version + 1;
            if (payload.removed) { const remSet = new Set(payload.removed); colliders = colliders.filter(c => !remSet.has(c.id)); }
            if (payload.updated) { const map = new Map(colliders.map(c => [c.id, c])); payload.updated.forEach(u => { const id = u.id ?? u.Id; if (map.has(id)) { Object.assign(map.get(id), normalizeCollider(u)); changeFlash.set(id, performance.now()); } }); colliders = Array.from(map.values()); }
            if (payload.added) { payload.added.forEach(a => { const na = normalizeCollider(a); colliders.push(na); changeFlash.set(na.id, performance.now()); }); }
            if (payload.bbox) { if (lastBbox) { const growth = (payload.bbox.width * payload.bbox.height) / (lastBbox.width * lastBbox.height + 0.0001); if (growth > 1.25 && displayState.autoFit) fitView(); } lastBbox = payload.bbox; }
            if (payload.stats) { pendingStats = { ...payload.stats, bbox: payload.bbox || { width: 0, height: 0 } }; }
            if (rebuildPlanes()) persistView();
            persistView();
            draw();
        });

        hub.on('roomAdded', payload => {
            if (!payload) return;
            if (rooms.some(r => (r.levelId ?? r.LevelId) === payload.levelId && (r.roomInstanceId ?? r.RoomInstanceId) === payload.roomInstanceId)) return;
            rooms.push({ levelId: payload.levelId, roomInstanceId: payload.roomInstanceId, name: payload.name });
            appendRoomToList(payload.levelId, payload.roomInstanceId, payload.name);
        });

        hub.on('roomRemoved', payload => {
            if (!payload) return;
            rooms = rooms.filter(r => (r.levelId ?? r.LevelId) !== payload.levelId || (r.roomInstanceId ?? r.RoomInstanceId) !== payload.roomInstanceId);
            const list = document.getElementById('roomList');
            if (list) {
                const selectorNew = `.collider-item[data-level-id="${payload.levelId}"][data-room-instance-id="${payload.roomInstanceId}"]`;
                const selectorLegacy = `.collider-item[data-levelid="${payload.levelId}"][data-roominstanceid="${payload.roomInstanceId}"]`;
                const item = list.querySelector(selectorNew) || list.querySelector(selectorLegacy);
                if (item) {
                    item.classList.add('fade-out');
                    const removeFn = () => { item.removeEventListener('transitionend', removeFn); if (item.parentNode) item.remove(); };
                    item.addEventListener('transitionend', removeFn);
                    setTimeout(removeFn, 400); // safety
                }
            }
            if (currentRoom && currentRoom.levelId === payload.levelId && currentRoom.roomInstanceId === payload.roomInstanceId) {
                currentRoom = null; colliders = []; version = 0; lastBbox = null; draw();
            }
        });

        function appendRoomToList(levelId, roomInstanceId, name) {
            const list = document.getElementById('roomList'); if (!list) return;
            const a = document.createElement('a');
            a.href = '#';
            a.className = 'list-group-item list-group-item-action collider-item';
            a.textContent = `${levelId}:${roomInstanceId} ${name || 'Unnamed'}`;
            // Canonical dataset assignments -> data-level-id / data-room-instance-id
            a.dataset.levelId = levelId;
            a.dataset.roomInstanceId = roomInstanceId;
            a.onclick = (e) => { e.preventDefault(); const r = { levelId, roomInstanceId, name }; selectRoom(r); highlightActiveRoom(levelId, roomInstanceId); };
            list.appendChild(a);
        }

    function persistView() { if (!currentRoom) return; const state = { zoom, offsetX, offsetY, active: [...activeTypes], planes: [...activePlanes].slice(0,1), displayState }; localStorage.setItem('colliderView_' + currentRoom.levelId + '_' + currentRoom.roomInstanceId, JSON.stringify(state)); }
    function restoreView() { if (!currentRoom) return false; const raw = localStorage.getItem('colliderView_' + currentRoom.levelId + '_' + currentRoom.roomInstanceId); if (!raw) return false; try { const s = JSON.parse(raw); if (typeof s.zoom === 'number' && typeof s.offsetX === 'number' && typeof s.offsetY === 'number') { zoom = s.zoom; offsetX = s.offsetX; offsetY = s.offsetY; } if (Array.isArray(s.active)) { activeTypes = new Set(s.active); buildFilters(); } if (s.displayState) { Object.assign(displayState, s.displayState); syncDisplayButtons(); } if (Array.isArray(s.planes) && s.planes.length) { activePlanes = new Set([s.planes[0]]); syncPlaneButtons(); } return true; } catch (_) { return false; } }

    function initUi() {
            if (initialized) return;
            initialized = true;
            const required = ['displayToggles','btnFit','searchBtn','searchCollider','exportJson','exportPng','colliderCanvas','toggleSidebar','planeToggles'];
            const missing = required.filter(id => !document.getElementById(id));
            if (missing.length) {
                if (document.readyState !== 'complete') {
                    return setTimeout(initUi, 40);
                }
                console.warn('Colliders page: missing expected elements:', missing.join(','));
            }
            const displayToggles = document.getElementById('displayToggles');
            if (!displayToggles) return;
            displayToggles.addEventListener('click', e => {
                const btn = e.target.closest('button.toggle-btn');
                if (!btn) return;
                const key = btn.dataset.key;
                if (!key) return;
                displayState[key] = !displayState[key];
                btn.classList.toggle('active', displayState[key]);
                btn.setAttribute('aria-pressed', displayState[key]);
                persistView();
                draw();
            });
            document.getElementById('btnFit')?.addEventListener('click', () => { fitView(); persistView(); draw(); });
            document.getElementById('searchBtn')?.addEventListener('click', () => searchCollider());
            document.getElementById('searchCollider')?.addEventListener('keydown', e => { if (e.key === 'Enter') searchCollider(); });
            document.getElementById('exportJson')?.addEventListener('click', () => { const data = JSON.stringify({ room: currentRoom, version, colliders }, null, 2); const blob = new Blob([data], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `colliders_${currentRoom?.levelId || 'unknown'}_${currentRoom?.roomInstanceId || 'x'}_v${version}.json`; a.click(); URL.revokeObjectURL(a.href); });
            document.getElementById('exportPng')?.addEventListener('click', () => { const canvas = document.getElementById('colliderCanvas'); const a = document.createElement('a'); a.href = canvas.toDataURL('image/png'); a.download = `colliders_${currentRoom?.levelId || 'unknown'}_${currentRoom?.roomInstanceId || 'x'}_v${version}.png`; a.click(); });
            document.getElementById('toggleSidebar')?.addEventListener('click', (e) => { const sb = document.getElementById('roomsSidebar'); if (!sb) return; sb.classList.toggle('collapsed'); const expanded = !sb.classList.contains('collapsed'); e.target.setAttribute('aria-expanded', expanded); e.target.textContent = expanded ? 'Hide Panel' : 'Show Panel'; });
                        document.getElementById('planeToggles')?.addEventListener('click', e => {
                            const btn = e.target.closest('button[data-plane]');
                            if (!btn) return;
                            const plane = parseInt(btn.dataset.plane,10);
                            if (Number.isNaN(plane)) return;
                            if (activePlanes.has(plane)) return;
                            activePlanes.clear();
                            activePlanes.add(plane);
                            syncPlaneButtons();
                            persistView();
                            draw();
                        });

            const colliderCanvas = document.getElementById('colliderCanvas');
            if (!colliderCanvas) return;
            colliderCanvas.addEventListener('mousemove', onCanvasMove);
            colliderCanvas.addEventListener('click', onCanvasClick);
            colliderCanvas.addEventListener('mousedown', e => { isPanning = true; startPan = { x: e.clientX, y: e.clientY }; document.body.style.cursor = 'grabbing'; });
            colliderCanvas.addEventListener('wheel', e => { e.preventDefault(); const canvas = e.target; const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; const prevZoom = zoom; zoom *= e.deltaY < 0 ? 1.1 : 0.9; zoom = Math.min(Math.max(zoom, 0.05), 20); offsetX = mx - (mx - offsetX) * (zoom / prevZoom); offsetY = my - (my - offsetY) * (zoom / prevZoom); draw(); }, { passive: false });
            colliderCanvas.addEventListener('dblclick', () => { fitView(); draw(); });
            document.getElementById('resetView')?.addEventListener('click', () => { fitView(); draw(); });

            hub.onclose(err => {
                if (!intentionalStop) {
                    console.warn('Collider hub closed (unexpected)', err);
                    setTimeout(() => { if (pageActive && hub.state === signalR.HubConnectionState.Disconnected) hub.start().catch(e => console.error('Restart failed', e)); }, 2000);
                } else {
                }
            });
            hub.onreconnecting(err => console.warn('Collider hub reconnecting...', err));
            hub.onreconnected(id => console.info('Collider hub reconnected', id));
            hub.start().then(() => { loadRooms(); resizeCanvas(); }).catch(err => console.error('Collider hub start failed', err));
            document.addEventListener('visibilitychange', () => { if (document.hidden) { suspendPage(); } else { resumePage(); } });
            window.addEventListener('beforeunload', () => { suspendPage(); });
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initUi);
        } else {
            initUi();
        }

        function searchCollider() {
            const term = document.getElementById('searchCollider').value.trim();
            if (!term) { selectedColliderId = null; document.getElementById('colliderDetail').textContent = ''; draw(); return; }
            const found = colliders.find(c => c.id.toLowerCase().includes(term.toLowerCase()));
            if (found) { selectedColliderId = found.id; document.getElementById('colliderDetail').textContent = `Selected: ${found.id} | ${found.type}`; panTo(found); draw(); announce(`Collider ${found.id} selected.`); }
        }
        function panTo(c) { const canvas = document.getElementById('colliderCanvas'); const cx = (c.x + c.width / 2) * scale * zoom + offsetX; const cy = (-(c.y + c.height / 2)) * scale * zoom + offsetY; const midX = canvas.width / 2; const midY = canvas.height / 2; offsetX += (midX - cx); offsetY += (midY - cy); }

    function onCanvasMove(e) {
            const canvas = e.target; const rect = canvas.getBoundingClientRect(); const mx = (e.clientX - rect.left - offsetX) / (zoom * scale); const my = -((e.clientY - rect.top - offsetY) / (zoom * scale));
            const showInactive = displayState.inactive; const showInvisible = displayState.invisible;
            const stack = colliders.filter(c => {
                if (!activeTypes.has(c.type)) return false;
                if (!showInactive && !c.active) return false;
                if (!showInvisible && c.invisible) return false;
                if (activePlanes.size && !activePlanes.has(c.plane)) return false;
                return mx >= c.x && mx <= c.x + c.width && my >= c.y && my <= c.y + c.height;
            });
            hoverStack = stack;
            const top = stack[0] || null;
            const info = document.getElementById('hoverInfo');
            if (info) {
                if (top) {
                    const extra = stack.length > 1 ? ` (+${stack.length - 1} more)` : '';
                    info.textContent = `${top.type} ${top.id} (${top.x.toFixed(2)},${top.y.toFixed(2)}) ${top.width.toFixed(2)}x${top.height.toFixed(2)}${extra}`;
                } else info.textContent = '';
            }
            if (top?.id !== lastHoverTopId || (stack.length > 1 && stack.length !== hoverStack.length)) {
                lastHoverTopId = top ? top.id : null;
                draw();
            } else if (!top && lastHoverTopId) { lastHoverTopId = null; draw(); }
        }
        function onCanvasClick(e) {
            const canvas = e.target; const rect = canvas.getBoundingClientRect(); const mx = (e.clientX - rect.left - offsetX) / (zoom * scale); const my = -((e.clientY - rect.top - offsetY) / (zoom * scale));
            const showInactive = displayState.inactive; const showInvisible = displayState.invisible;
                const stack = colliders.filter(c => activeTypes.has(c.type) && (showInactive || c.active) && (showInvisible || !c.invisible) && (!activePlanes.size || activePlanes.has(c.plane)) && mx >= c.x && mx <= c.x + c.width && my >= c.y && my <= c.y + c.height);
                if (stack.length === 0) { selectedColliderId = null; draw(); announce('Selection cleared.'); return; }
                const now = performance.now();
                const idSet = new Set(stack.map(c => c.id));
                if (lastClickStack && (now - lastClickStack.time < 1500) && idSet.size === lastClickStack.ids.size && [...idSet].every(id => lastClickStack.ids.has(id))) {
                    lastClickStack.index = (lastClickStack.index + 1) % stack.length;
                    selectedColliderId = stack[lastClickStack.index].id;
                    lastClickStack.time = now;
                } else {
                    selectedColliderId = stack[0].id;
                    lastClickStack = { ids: idSet, index: 0, time: now };
                }
                const sel = stack.find(c => c.id === selectedColliderId);
                const detail = document.getElementById('colliderDetail');
                if (detail && sel) detail.textContent = `Selected: ${sel.id} | ${sel.type} | Pos(${sel.x.toFixed(2)},${sel.y.toFixed(2)}) Size(${sel.width.toFixed(2)}x${sel.height.toFixed(2)}) Plane:${sel.plane}${stack.length>1 ? ` (stack ${lastClickStack.index+1}/${stack.length})` : ''}`;
                if (sel) announce(`Collider ${sel.id} selected.${stack.length>1 ? ' Stack item '+(lastClickStack.index+1)+' of '+stack.length+'. Click to cycle.' : ''}`);
                draw();
        }

        window.addEventListener('mouseup', () => { isPanning = false; document.body.style.cursor = 'default'; });
        window.addEventListener('mousemove', e => { if (!isPanning) return; const dx = e.clientX - startPan.x; const dy = e.clientY - startPan.y; startPan = { x: e.clientX, y: e.clientY }; offsetX += dx; offsetY += dy; draw(); });

    function syncDisplayButtons() {
            const container = document.getElementById('displayToggles'); if (!container) return;
            [...container.querySelectorAll('button.toggle-btn')].forEach(b => {
        const key = b.dataset.key; if (!key) return; const state = !!displayState[key]; b.classList.toggle('active', state); b.setAttribute('aria-pressed', state);
            });
        }

    function rebuildPlanes() {
        const planes = Array.from(new Set(colliders.map(c => c.plane).filter(p => p !== undefined))).sort((a,b)=>a-b);
        const changed = planes.length !== knownPlanes.length || planes.some((p,i)=>p!==knownPlanes[i]);
        if (!changed) return false;
        knownPlanes = planes;
        const current = [...activePlanes][0];
        if (!planes.includes(current)) {
            activePlanes.clear();
            if (planes.length) activePlanes.add(planes[0]);
        } else {
            activePlanes = new Set([current]);
        }
        const container = document.getElementById('planeToggles'); if (!container) return false;
        container.innerHTML='';
        planes.forEach(p => {
            const btn = document.createElement('button');
            btn.type='button';
            btn.className='btn btn-sm btn-outline-dark toggle-btn';
            btn.dataset.plane = p;
            btn.textContent = 'Plane'+p;
            const active = activePlanes.has(p);
            btn.setAttribute('aria-pressed', active);
            if (active) btn.classList.add('active');
            container.appendChild(btn);
        });
        return true;
    }

    function syncPlaneButtons() {
        const container = document.getElementById('planeToggles'); if (!container) return;
        [...container.querySelectorAll('button[data-plane]')].forEach(b => {
            const p = parseInt(b.dataset.plane,10);
            const on = activePlanes.has(p);
            b.classList.toggle('active', on);
            b.setAttribute('aria-pressed', on);
        });
    }

    function announce(message) {
        const region = document.getElementById('srAnnounce');
        if (!region) return;
        region.textContent = '';
        setTimeout(() => { region.textContent = message; }, 30);
    }
    </script>
}
